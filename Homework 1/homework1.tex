\documentclass[11pt]{exam}
\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[colorlinks,linkcolor=blue]{hyperref}

% in order to compile this file you need to get 'header.tex' from
% Canvas and change the line below to the appropriate file path
\input{header}

\geometry{left=2.5 cm,right=2.5 cm,top=2.5 cm,bottom=2.5 cm}
%\pagestyle{fancy}
\definecolor{mygreen}{rgb}{0,0.6,0}  
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82} 
\definecolor{background}{rgb}{0.963,0.963,0.963}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\newcommand{\hwnum}{1}
\newcommand{\duedate}{Oct 8 23:59, 2021}

%\notesheader
\hwheader   % header for homework
%\hwslnheader   % header for homework solutions

% Comment the following line in order to hide solutions.
% Uncomment the line to show solutions written inside of
% LaTeX solution environments like:
%   \begin{solution}
%     My solution.
%   \end{solution}.
\printanswers

\begin{document}
\setlength{\parindent}{0pt}
\section*{Before you start:}

\subsection*{Homework Files}
You can download the starter files for coding as well as this \textit{tex} file (you only need to modify \textit{homework1.tex}) on canvas and do your homework with latex. Or you can scan your handwriting, convert to pdf file, and upload it to canvas before the due date. If you choose to write down your answers by hand, you can directly download the pdf file on canvas which provides more blank space for solution box.\\

\subsection*{Submission Form}
For homework 1, there are two parts of submission:
\begin{enumerate}
    \item A pdf file as your solution named as VE281\_HW1\_[Your Student ID]\_[Your name].pdf uploaded to canvas
    \item Code for 3.2 uploaded to joj (there will be hidden cases but the time restriction is similar to the pretest cases).
\end{enumerate}
For the programming question(question 3.2),you must make sure that your code compiles successfully on a Linux operating system with g++ and the options:
\begin{lstlisting}[language=bash]
-std=c++1z -Wconversion -Wall -Werror -Wextra -pedantic
\end{lstlisting}

Estimated time used for this homework: \textbf{4-5 hours.}
\\\\
Great credits to 2020FA VE281 TA Group and enormous thanks to 2021SU VE281 TA Roihn!

\newpage
\section*{0\quad Student Info (0 point)}
Your name and student id:
\begin{solution}
% Write your answer here
\end{solution}

\section{Complexity Analysis (20 points, after Lec2)}

\begin{enumerate}[(a)]

\item Based on the given code, answer the following questions:(4 points)
\begin{lstlisting}[language=c++]
void question_1a(int n) {
	 int count = 0;
	 for (int i = 0; i < n; i++) {
	 	for (int j = i; j > 0; j--) {
	 		count += 1;
	 	}
	 }
	cout << count << endl;
}
\end{lstlisting}
\begin{enumerate}[i)]
\item What is the output? Describe the answer with variable $n$. (1 points)
\item What is the time complexity of the following function? What do you find when comparing it with your answer of the previous part i)? (3 points)
\end{enumerate}

\begin{solution}
% Write your answer here
\end{solution}

\item What is the time complexity of the following function? (4 points)
\begin{lstlisting}[language=c++]
void question_1b(int N, int M, int K) {
	int count = 0;
	for (int i = 0; i < N; i += 2) {
		for (int j = 0; j < M / 2; j++) {
			count++;
		}
	}
	for (int i = 0; i < K; i++) {
		count--;
	}
}
\end{lstlisting}

\begin{solution}
% Write your answer here
\end{solution}

\item What is the time complexity of the following function? Select \textbf{All} the answers that are correct, and state your reason.  (4 points)
\begin{lstlisting}[language=c++]
void question_1c(int n) {
	int count = 0;
	int m = static_cast<int>(floor(sqrt(n)));
	for (int i = n/2; i < n; i++) {
		for (int j = 1; j < n; j = 2*j) {
			for (int k = 0; k < n; k += m) {
				count++;
			}
		}
	}
}
\end{lstlisting}
\begin{enumerate}[A)]
\item $\Theta(n^{1/2}\log n)$
\item $\Theta(n \log n)$
\item $O(n \log n)$
\item $\Theta(n^{3/2}\log n)$
\item $\Theta(n^2\log n)$
\item $O(n^{5/2}\log n)$
\item $\Theta(n^{5/2}\log n)$
\end{enumerate}
\begin{solution}
% Write your answer here
\end{solution}

\item What is the time complexity of the following function? Show your steps. (4 points)
\begin{lstlisting}[language=c++]
int unknown_function(int n) {
	if (n <= 1) return 1;
	return n * (unknown_function(n-1));
}
\end{lstlisting}
\begin{solution}
% Write your answer here
\end{solution}

\item Consider the following four statements regarding algorithm complexities:
\begin{enumerate}[i)]
\item an algorithm with a $\Theta(n^2)$ time complexity will always run faster than an algorithm with a $\Theta(n \log n)$ time complexity.
\item an algorithm with a $\Theta(n \log n)$ time complexity will always run faster than an algorithm with a $\Theta(n^2)$ time complexity.
\item an algorithm with a $\Theta(n^2)$ time complexity will always run faster than an algorithm with a $\Theta(n!)$ time complexity.
\item an algorithm with a $\Theta(n!)$ time complexity will always run faster than an algorithm with a $\Theta(n^2)$ time complexity.
\end{enumerate}

How many of these statements are true? Show your reasons. (4 points)
\begin{solution}
% Write your answer here
\end{solution}

\end{enumerate}
\newpage
\section{Master Theorem (15 points, after Lec3)}
\subsection{Recurrence Relation (9 points)}
What is the complexity of the following recurrence relation? (if not mentioned, please state it with big-theta notation.)
\begin{enumerate}[(a)]

\item $T(n) = \left\{
\begin{aligned}
&c_0, &n=1\\
&4T\left(\dfrac{n}{2}\right)+16n+n^2+c, &n>1\\
\end{aligned}
\right.
$

\begin{solution}
% Write your answer here
\end{solution}

\item $T(n) = \left\{
\begin{aligned}
&c_0, &n=1\\
&5T\left(\dfrac{n}{25}\right)+\sqrt{n}+c, &n>1\\
\end{aligned}
\right.
$

\begin{solution}
% Write your answer here
\end{solution}

\item $T(n) = \left\{
\begin{aligned}
&c_0, &n=1\\
&3T(n-1)+c, &n>1\\
\end{aligned}
\right.
$ (Hint: Can you still use master theorem here?)
\begin{solution}
% Write your answer here
\end{solution}
\end{enumerate}

\subsection{Master Theorem on code (6 points)}
Based on the function below, answer the following question. \textbf{Assume that $cake(n)$ runs in $\log n$ time.}
\begin{lstlisting}[language=c++]
void pie(int n) {
	if (n == 1) {
		return;
	}
	pie(n / 7);
	int cookie = n * n;
	for (int i = 0; i < cookie; ++i) {
		for (int j = 0; j < n; ++j) {
			cake(n);
		}
	}
	for (int k = 0; k < n; ++k) {
		pie(n / 3);
	}
	cake(cookie * cookie);
}
\end{lstlisting}
Calculate the recurrence relation of this function.
\begin{solution}
% Write your answer here
\end{solution}

\section{Sorting Algorithms (45 points, after Lec4)}

\subsection{Sorting Basics (9 points)}
{In this part, you only need to write down your choice. No explanation is required. }
\subsubsection{Sorting algorithms' working scenarios (3 points)}

What is the most efficient sorting algorithm for each of the following situations?
\begin{enumerate}[(a)]
    \item A small array of integers.
    \begin{enumerate}[A)]
        \item insertion sort
        \item selection sort
        \item quick sort
        \item bucket sort
    \end{enumerate}
    \begin{solution}
        % Write your answer here
    \end{solution}
    
    \item A large array of integers that is already almost sorted.
    \begin{enumerate}[A)]
        \item insertion sort
        \item selection sort
        \item quick sort
        \item bucket sort
    \end{enumerate}
    \begin{solution}
        % Write your answer here
    \end{solution}
    
    \item A large collection of integers that are drawn from a very small range.
    \begin{enumerate}[A)]
        \item insertion sort
        \item selection sort
        \item quick sort
        \item bucket sort
    \end{enumerate}
    \begin{solution}
        % Write your answer here
    \end{solution}
\end{enumerate}

% Try to state your explanation from the following perspectives: The number of swaps / copies / compares; Time complexity; special cases depend on input; ...


\subsubsection{Sorting snapshots (6 points)}

\begin{enumerate}[(a)]
    \item Suppose you had the following unsorted array:
        \begin{center}
            \{22, 9, 13, 52, 66, 74, 28, 59, 71, 35, 11, 47\}
        \end{center}
        A snapshot is taken during execution of a sorting algorithm. If the snapshot of the array is:
        \begin{center}
            \{9, 13, 22, 52, 66, 74, 28, 59, 71, 11, 35, 47\}
        \end{center}
        which of the following sorts is currently being run on this array?
        \begin{enumerate}[A)]
            \item bubble sort
            \item insertion sort
            \item selection sort
            \item quick sort
            \item merge sort
            \item none of above
        \end{enumerate}
        \begin{solution}
        % Write your answer here
        \end{solution}
    \item Suppose you had the following unsorted array:
        \begin{center}
            \{22, 9, 13, 52, 66, 74, 28, 59, 71, 35, 11, 47\}
        \end{center}
        A snapshot is taken during execution of a sorting algorithm. If the snapshot of the array is:
        \begin{center}
            \{9, 11, 13, 22, 28, 74, 66, 59, 71, 35, 52, 47\}
        \end{center}
        which of the following sorts is currently being run on this array?
        \begin{enumerate}[A)]
            \item bubble sort
            \item insertion sort
            \item selection sort
            \item quick sort
            \item merge sort
            \item none of above
        \end{enumerate}
        \begin{solution}
        % Write your answer here
        \end{solution}
    \item Suppose you had the following unsorted array:
        \begin{center}
            \{22, 9, 13, 52, 66, 74, 28, 59, 71, 35, 11, 47\}
        \end{center}
        A snapshot is taken during execution of a sorting algorithm. If the snapshot of the array is:
        \begin{center}
            \{22, 9, 13, 11, 35, 28, 47, 59, 71, 66, 52, 74\}
        \end{center}
        which of the following sorts is currently being run on this array?
        \begin{enumerate}[A)]
            \item bubble sort
            \item insertion sort
            \item selection sort
            \item quick sort
            \item merge sort
            \item none of above
        \end{enumerate}
        \begin{solution}
        % Write your answer here
        \end{solution}
\end{enumerate}

\subsection{Squares of a Sorted Array (17 points)}
Sxt is now doing his homework1 for VE281. He is given an integer array $A$ sorted in \textbf{non-decreasing order (non-positive numbers included)}, and is required to return an array of the \textbf{squares} of each number sorted in non-decreasing order. It is guaranteed that there is \textbf{always one zero($0$)} in the given array. 
Here is Sxt's code:
\begin{lstlisting}[language=c++]
#include <iostream>
using namespace std;

// REQUIRES: an array A and its size n
// EFFECTS: sort array A
// MODIFIES: array A
void insertion_sort(int *A, size_t size) {
    for (size_t i = 1; i < size; i++) {
        size_t j = 0;
        while (j < i && A[i] >= A[j]) {
            j++; // Find the location to insert the value
        }
        int tmp = A[i]; // Store the value we need to insert
        for (size_t k = i; k > j; k--) {
            A[k] = A[k-1];
        }
        A[j] = tmp;
    }
}

int main(){
    int A[5] = {-4, -1, 0, 3, 10};
    size_t sizeA = 5;
    for (size_t i = 0; i < sizeA; i++) { //Calculate the square of input array
        A[i] = A[i] * A[i];
    }
    insertion_sort(A, sizeA);
    for (auto item: A) {
        cout << item << ' ';
    }
    cout << endl;
    return 0;
}
\end{lstlisting}

However, after discussing with Jhf, he finds his code runs slowly when it encounters array with great length. Also, he guesses some operations maybe useless in his code because of the \textbf{special property of the input array}. Hence, he hopes that you can help him find out where he can improve his code to have \textbf{$O(n)$ time complexity}. \textbf{You should follow the provided starter file.} 
\newline

In the starter file, we have finished the IO part for you, and here is the IO rule:\\
\textbf{Input format}: an integer array $A$ sorted in non-decreasing order with always one zero (non-positive numbers included)\\
\textbf{Output format}: an array of the squares of each number sorted in non-decreasing order
\newline
\vspace{0.2cm}

Here are some demos:
\begin{itemize}
    \item \textbf{Sample 1}\\
    Input: \lstinline|-1 0 1| \\
    Output: \lstinline|0 1 1|
    \item \textbf{Sample 2}\\
    Input: \lstinline|-4 -2 0 1 3| \\
    Output: \lstinline|0 1 4 9 16|
\end{itemize}
% \newline

*You can find the starter code in the given starter file \textit{square.cpp}. Please finish the \lstinline|square_sort()| function in \textit{square.cpp} file, and upload the file to joj(DO NOT CHANGE THE FILE NAME!!). \\
*Since the cases on joj are quite small, they are just used for you to briefly check the correctness of your code. We will manually check the time complexity of your code.


\subsection{Tim Sort (12 points)}
Suppose that We want to find the $6^{th}$ largest element, which is 6, in the following array, Insertion sort is a simple and fast algorithm when the length of array n is short. However, when n goes large, insertion sort may not be the best choice, as the worst case time complexity is $O(n^2)$. We can speed up insertion sort by combining it with merge in mergeSort we learnt in the lectures.

\begin{algorithm}[H]
	\textbf{Input}: an array a of n elements, and integer x > 0 (you can assume that $x\ll n$)\\
	\textbf{Output}: the sorted array of a
	\caption{timSort(a[.],x)}
	
	\begin{algorithmic}[1]
	    \For{i $=$ 0; i $<$ n; i $+=$ x }  
            \State insertionSort(a,i,min(i+x-1, n-1));  
        \EndFor  
        \For{step $=$ x; step $<$ n; step $*=$ 2}
            \For{left $=$ 0; left $<$ n; left $+=$ 2 $*$ step}
                \State mid = left + step - 1;
                \State right = min(left + 2$*$step - 1, n - 1);
                \State merge(a, left, mid, right);
            \EndFor
        \EndFor
	\end{algorithmic}  
\end{algorithm}

The algorithm is used as the default sorting algorithm in Java and Python. Herem we assume that $x \ll n$ is a known constant.
\begin{enumerate}[(a)]
\item Suppose n = 1000 and x = 32. How many times will insertionSort be performed?

\item Suppose x = 32. Express in terms of n how many comparisons in the worst case will be performed in insetionSort.

\item Express the worst case running time of the whole algorithm in terms of big-Oh notation.

\item Is this algorithm in-place? If not, express the additional space needed in terms of the big-Oh notation.

\end{enumerate}

\begin{solution}
% Write your answer here
\end{solution}

\subsection{Quicker sort simulation (7 points)}
To fully understand the mechanism of sorting algorithm, please simulate the given array for each iteration of required algorithm.

\subsubsection{Quick sort (3 points)}

Assume that we always choose the \textbf{first entry} as the pivot to do the partition, and we want to sort the array in \textbf{ascending order}. Then, for the following array:
\begin{align*}
A = \{6, 2, 8, 10, 3, 1, 9\}
\end{align*}

Sxt shares his answer for this array:
\begin{solution}
% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[H]
  \centering
    \begin{tabular}{lllll}
    Iter  & Current Subarray & Pivot & Swapped Subarray & Current Array \\
    \hline
    1     & $\{6,2,8,10,3,1,9\}$ & 6     & $\{3,2,1,6,10,8,9\}$ & $\{3,2,1,6,10,8,9\}$ \\
    2     & $\{3,2,1\}$ & 3     & $\{1,2,3\}$ & $\{1,2,3,6,10,8,9\}$ \\
    3     & $\{1,2\}$ & 1     & $\{1,2\}$ & $\{1,2,3,6,10,8,9\}$ \\
    4     & $\{\}$ & None  & $\{\}$ & $\{1,2,3,6,10,8,9\}$ \\
    5     & $\{2\}$ & None  & $\{2\}$ & $\{1,2,3,6,10,8,9\}$ \\
    6     & $\{\}$ & None  & $\{\}$ & $\{1,2,3,6,10,8,9\}$ \\
    7     & $\{10,8,9\}$ & 10    & $\{9,8,10\}$ & $\{1,2,3,6,9,8,10\}$ \\
    8     & $\{9,8\}$ & 9     & $\{8,9\}$ & $\{1,2,3,6,8,9,10\}$ \\
    9     & $\{8\}$ & None  & $\{8\}$ & $\{1,2,3,6,8,9,10\}$ \\
    10    & $\{\}$ & None  & $\{\}$ & $\{1,2,3,6,8,9,10\}$ \\
    11    & $\{\}$ & None  & $\{\}$ & $\{1,2,3,6,8,9,10\}$ \\
    \end{tabular}%
\end{table}%

*Brief explanation:
You need to strictly follow the algorithm we learned in class as the following (since there are so many different kinds of quick sort with slight changes).
\begin{lstlisting}[language=c++]
void quicksort(int *a, int left, int right) {
	int pivotat; // index of the pivot
	if(left >= right) return;
	pivotat = partition(a, left, right);
	quicksort(a, left, pivotat-1);
	quicksort(a, pivotat+1, right);
}
\end{lstlisting}

The steps above strictly follows the recursion order. For example, for iter 4, this is the left half part of iter 3, while iter 5 is the right half part of iter 3.
\end{solution}

Now please simulate quick sort for the following array:
\begin{align*}
A = \{6, 2, 8, 5, 11, 10, 4, 1, 9, 7, 3\}
\end{align*}
You should follow the format that Sxt has shared.
\begin{solution}
% Write your answer here
\end{solution}

\subsubsection{Merge Sort (4 points)}
For the following array:
\begin{align*}
A = \{6, 2, 8, 10, 3, 1, 7\}
\end{align*}

Sxt shares part of his answer for applying merge sort to the given array: 
\begin{solution}

1. Division: $\{6,2,8,10\}\;\{3,1,7\}$

2. Division: $\{6,2\}\;\{8,10\}\;\{3,1,7\}$

3. Division: $\{6\}\;\{2\}\;\{8,10\}\;\{3,1,7\}$

4. Merge: $\{2,6\}\;\{8,10\}\;\{3,1,7\}$

5. Division / Merge: $\dots$

$\dots$

Last. Merge: $\{1,2,3,6,7,8,10\}$
\end{solution}

Now please simulate merge sort for the following array:
\begin{align*}
A = \{6, 2, 8, 5, 11, 10, 4, 1, 9, 7, 3\}
\end{align*}
Please show all the details of each division or merge. 
\begin{solution}
% Write your answer here
\end{solution}
\newpage
\section{Selection Algorithm (20 points, after Lec5)}

\begin{enumerate}[(a)]
\item Coned is an undergraduate student taking VE281. He is interested in \textbf{random} selection algorithm and wondering which scenario will be the \textbf{worst-case} one.
\begin{itemize}
    \item For the following input sequence, can you give out the pivot sequence for the worst-case scenario? Suppose that we are finding the 3-rd biggest element. (6 points)\\
    Input sequence:
    $$37,7,31,27,22,13,46$$
    Solution format for the pivot sequence:\\
    (Certainly the pivot selection is not correct for the requirement :) It is only for clarifying the format.)
    \begin{solution}
    \\
    Pick 22: 7,13,22,37,31,27,46\\
    Pick 46: 7,13,22,37,31,27,46\\
    Pick 37: 7,13,22,31,27,37,46\\
    ...
    \end{solution}
\item What is the time complexity of the worst-case scenario? (2 points)
\end{itemize}
\item William is a master of algorithm. He thinks that Coned's selection algorithm is too naive and prefers \textbf{deterministic} selection algorithm. However, since his favorite number is 7, he \textbf{partitions the numbers by groups of 7 rather than 5}. He is confident that such a change will make no difference to the time complexity of the algorithm. Is him right? Namely, will the time complexity of William's new selection algorithm \textbf{still be $O(n)$}, where n is the amount of input numbers? Give your proof. (8 points)
\item When we consider the time complexity of an algorithm, we usually ignore the constant coefficients since we care about large $n$. Similarly, if we only consider the large cases, which algorithm do you think may work better, deterministic or random? State your reason in detail. (4 points) (Hint: think about William's change and what professor said in the lecture before you have your answer.)
\end{enumerate}

\begin{solution}
% Write your answer here
\end{solution}

\end{document}